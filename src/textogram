#!/usr/bin/env python

import ipdb
import numpy as np


'''
A script to read in a list of numbers and output an ASCII histogram of them.
Various optional arguments control the format of the output.

Example: Here's me finding out how long my commit titles are.

$ git log --format=%s | awk '{print length}' | textogram -a 0 -z 60 -n 12

 0 - 5  :                                                     (1.0)
 5 - 10 : ############                                        (30.0)
10 - 15 : ###########################                         (66.0)
15 - 20 : ##################################################  (118.0)
20 - 25 : #################################################   (116.0)
25 - 30 : #####################################               (89.0)
30 - 35 : ###############################                     (74.0)
35 - 40 : ################################                    (76.0)
40 - 45 : ########################                            (58.0)
45 - 50 : ##################                                  (44.0)
50 - 55 : ###                                                 (9.0)
55 - 60 :                                                     (0.0)
    >60 : (4)
'''


# TO DO: Have plot return an object that can with other, new methods, be used
# to generate new plots -- e.g. with different bins -- without recomputing
# everything from raw data again.


def textogram(vals, **kwargs):
    print get_textogram(vals, **kwargs)

def get_textogram(vals, bins=None, N=10, xmin=None, xmax=None, with_counts=True, yscale='lin', height=60):
    vals = np.array(vals).astype(float)
    v_min = xmin if xmin is not None else min(vals)
    v_max = xmax if xmax is not None else max(vals)
    left_edges = np.linspace(v_min, v_max, N+1) if bins is None else bins
    n_tot = len(vals)
    left_tail = vals[(vals < left_edges[0])]
    right_tail = vals[(vals > left_edges[-1])]
    vals = vals[(vals >= left_edges[0]) & (vals <= left_edges[-1])]
    bin_vals = hist(vals, left_edges)
    bin_counts = list(bin_vals)
    if yscale == 'log':
        bin_vals[bin_vals > 0] = np.log2(bin_vals[bin_vals > 0]) + 1
    labels = get_bin_labels(left_edges, left_tail=len(left_tail)>0, right_tail=len(right_tail)>0)
    s = '\n'
    bin_val_max = max(bin_vals)
    max_bar_height = height
    sep = ' - '
    pct_fmt = '{: >3d}'
    if len(left_tail) > 0:
        s += labels.pop(0) + ' : ' + format_percentage(len(left_tail)/float(n_tot), fmt='{:d}') + ' (' + str(len(left_tail)) + ')\n'
    for i in range(len(left_edges)-1):
        prefix = labels[i] + ' : '
        prefix_length = len(prefix)
        s += prefix
        bar_height = int(max_bar_height * bin_vals[i] / bin_val_max)
        s += '#' * bar_height + ' ' * (max_bar_height - bar_height)
        if with_counts:
            s += ' ' * 2 + format_percentage(bin_counts[i]/n_tot) + ' (' + str(bin_counts[i]) + ')'
        s += '\n'
    if len(right_tail) > 0:
        s += labels[-1] + ' : ' + format_percentage(len(right_tail)/float(n_tot), fmt='{:d}') + ' (' + str(len(right_tail)) + ')\n'
    return s

def hist(vals, left_edges):
    res = []
    for i in range(len(left_edges)-1):
        res.append(len(vals[(vals >= left_edges[i]) & (vals < left_edges[i+1])]))
    return res

def format_percentage(r, fmt='{: >3d}'):
    return fmt.format(int(100 * r)) + '%'

def get_bin_labels(edges, left_tail=False, right_tail=False):
    w = max(map(lambda x: len(str(int(x))), edges))
    min_step = np.inf
    for i in range(len(edges)-1):
        min_step = min(min_step, edges[i+1] - edges[i])
    if min_step < 1:
        p = -int('{:e}'.format(min_step).split('e')[1])
    else:
        p = 0
    res = []
    fmt_suffix = str(w+p) + '.' + str(p) + 'f}'
    for i in range(len(edges)-1):
        label = ('{: >' + fmt_suffix).format(edges[i])
        label += ' - '
        label += ('{: <' + fmt_suffix).format(edges[i+1])
        res.append(label)
    if left_tail:
        label = '<' + ('{:' + fmt_suffix).format(edges[0])
        label = ' ' * (len(res[0]) - len(label)) + label
        res.insert(0, label)
    if right_tail:
        label = '>' + ('{:' + fmt_suffix).format(edges[-1])
        label = ' ' * (len(res[0]) - len(label)) + label
        res.append(label)
    return res

def main(args):
    with open(args.infile, 'rb') as fp:
        vals = []
        for line in fp:
            try:
                vals.append(float(line.strip()))
            except ValueError:
                pass
    kwargs = {
            'bins': args.bins,
            'height': args.height,
            'with_counts': args.with_counts,
            'xmin': args.min,
            'xmax': args.max,
            'yscale': args.yscale,
            }
    textogram(vals, **kwargs)


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('infile', nargs='?', default='/dev/stdin')
    parser.add_argument('--bins', '-b', nargs='+')
    parser.add_argument('--height', type=int, default=50)
    parser.add_argument('--min', '-a', type=float)
    parser.add_argument('--max', '-z', type=float)
    parser.add_argument('--num-bins', '-n', type=int, default=10)
    parser.add_argument('--yscale', '-y', choices=['lin', 'log'], default='lin')
    parser.add_argument('--with-counts', action='store_false')
    args = parser.parse_args()
    main(args)

